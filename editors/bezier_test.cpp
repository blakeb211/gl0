#define OLC_PGE_APPLICATION
#include "..\include\headers.h"
#include "olcPixelGameEngine.h"
#include "..\include\gamelib.h"
#include "..\include\glm.h" 

using namespace std;

using vec3 = glm::vec3;

constexpr auto WORLD_Y_MAX = 30.0f;
constexpr auto comp_zmax = [](const glm::vec3 & a, const glm::vec3 & b) -> bool { return a.z < b.z; }; 
constexpr auto comp_ymax = [](const glm::vec3 & a, const glm::vec3 & b) -> bool { return a.y < b.y; }; 

//@TODO: 
//campath editor operates in world coordinators
//label axes
//pop up pt coords
//print out scale of level in world coordinates
//print out camPath points in a table
//ability to toggle between default view (ZY) an alternate view (ZX)
//ability to drag control points to change the path
//make autogenerated path points evenly spaced

struct camPath {
	camPath() = delete;
	camPath(vector<vec3> control_points) { cps = control_points; }
	void createPathFromCps() {
		// 0 1 2 3 4 5

		for (int cpIdx = 0; cpIdx <= cps.size() - 3; cpIdx += 2) {
			const vec3& p0 = cps[cpIdx];
			const vec3& p1 = cps[cpIdx + 1];
			const vec3& p2 = cps[cpIdx + 2];
			float x, y, z, t;
			x = y = z = t = 0.0f;
			while (t < 1.0) {
				x = (1 - t) * (1 - t) * p0.x + 2 * (1 - t) * t * p1.x +
					t * t * p2.x;
				y = (1 - t) * (1 - t) * p0.y + 2 * (1 - t) * t * p1.y +
					t * t * p2.y;
				z = (1 - t) * (1 - t) * p0.z + 2 * (1 - t) * t * p1.z +
					t * t * p2.z;
				pts.push_back(vec3{x, y, z});
				t += 0.10f;
			}
		}
	}
	vector<vec3> cam_dir;
	vector<vec3> pts;
	vector<vec3> cps;
};

enum class View {
	ZY = 0,
	ZX = 1,
};

class Example : public olc::PixelGameEngine {
	public:
		View currView{};
		unique_ptr<camPath> path;
		Example() { sAppName = "Example"; }
		bool OnUserCreate() override {
			// Called once at the start, so create things here
			vector<vec3> cps = 
			{
				vec3{0.0f, 10.0f, 0.f},
				vec3{ 0.0f, 10.0f,0.f},
				vec3{ 0.f, 15.0f,85.f},
				vec3{ 0.f, 15.0f,100.f},
				vec3{ 0.f, 18.0f,110.f},
				vec3{ 0.f, 22.0f,120.f},
				vec3{ 0.f, 20.0f,150.f},
				vec3{ 0.f, 19.0f,180.f},
				vec3{ 0.f, 20.0f,200.f}};
			path = make_unique<camPath>(camPath(cps));
			cout << "number of control points: " << path->cps.size() << endl;
			path->createPathFromCps();
			return true;
		}

		bool OnUserUpdate(float fElapsedTime) override {

			this->Clear(olc::Pixel(olc::DARK_GREY));


			// draw axes
			// ZY
			// Z = 0 					X = ScreenHeight / 2
			// Z = WorldZMax 			X = ScreenWidth
			// Y = 0 					ScreenHeight / 2
			// Y = WorldYMax 			0
			//
			float y_offset{}, x_offset{};
			float y_scale{}, x_scale{};



			auto z_data_max_it = std::max_element(path->pts.begin(), path->pts.end(), comp_zmax);
			auto y_data_max_it = std::max_element(path->pts.begin(), path->pts.end(), comp_ymax);
			auto z_data_max = (*z_data_max_it).z;
			auto y_data_max = (*y_data_max_it).y;
			//cout << "z_data_max:" << z_data_max << endl;
			//cout << "y_data_max:" << y_data_max << endl;

			switch(currView) {
				case View::ZY:
					// y = y + ScreenHeight/2
					y_offset = ScreenHeight()/2;
					x_offset = 5;
					y_scale = WORLD_Y_MAX / y_data_max;
					x_scale = ScreenWidth() / (z_data_max + 5);
					DrawLine(0, y_offset, ScreenWidth(), y_offset, olc::WHITE);
					DrawLine(ScreenWidth()/2, 0, ScreenWidth()/2, ScreenHeight(), olc::WHITE);
					break;
				case View::ZX:
					break;
			};


			// draw path
			// draw control points	
			switch(currView) {
				case View::ZY:

					for (const auto & pt : path->pts) {
						auto const y_coord = ScreenHeight() - ( (pt.y + y_offset) * y_scale );
						auto const x_coord = pt.z * x_scale;
						Draw(x_coord,y_coord, olc::Pixel(255, 0, 10));
						DrawCircle(x_coord,y_coord,3, olc::RED);
					}

					for (const auto & pt : path->cps) {
						// draw circles around control pts
						auto const y_coord = ScreenHeight() - ( (pt.y + y_offset) * y_scale );
						auto const x_coord = pt.z * x_scale;
						Draw(x_coord, y_coord , olc::Pixel(0, 255, 10));
						DrawCircle(x_coord, y_coord, 3, olc::GREEN);
					}

					break;
				case View::ZX:



					break;
			};





			return true;
		}
};




int main() {
	setLogFile("log.txt");
	auto level = gxb::load_level("test");
	Example demo;
	// this matches a screen dimension of roughly 1000x700
	if (demo.Construct(500, 350, 2, 2, false, true, false))
		demo.Start();

	return 0;
}
