#define OLC_PGE_APPLICATION
#include "..\include\gamelib.h"
#include "..\include\glm.h"
#include "..\include\headers.h"
#include "olcPixelGameEngine.h"

using namespace std;
using vec3 = glm::vec3;

/************************************************/
/*					GLOBALS
 */
/************************************************/
size_t frameCnt = 0;
constexpr auto WORLD_Y_MAX = 30.0f;
float z_data_max{};
float y_data_max{};
float x_data_max{};
/************************************************/

constexpr auto comp_zmax = [](const glm::vec3& a, const glm::vec3& b) -> bool {
    return a.z < b.z;
};
constexpr auto comp_ymax = [](const glm::vec3& a, const glm::vec3& b) -> bool {
    return a.y < b.y;
};
constexpr auto comp_xmax = [](const glm::vec3& a, const glm::vec3& b) -> bool {
    return a.x < b.x;
};

//@TODO:
// campath editor operates in world coordinators
// label axes
// pop up pt coords
// print out scale of level in world coordinates
// print out camPath points in a table
// ability to toggle between default view (ZY) an alternate view (ZX)
// ability to drag control points to change the path
// make autogenerated path points evenly spaced

struct camPath {
    camPath() = delete;
    camPath(vector<vec3> control_points) { cps = control_points; }
    void createPathFromCps() {
	// 0 1 2 3 4 5

	for (int cpIdx = 0; cpIdx <= cps.size() - 3; cpIdx += 2) {
	    const vec3& p0 = cps[cpIdx];
	    const vec3& p1 = cps[cpIdx + 1];
	    const vec3& p2 = cps[cpIdx + 2];
	    float x, y, z, t;
	    x = y = z = t = 0.0f;
	    while (t < 1.0) {
		x = (1 - t) * (1 - t) * p0.x + 2 * (1 - t) * t * p1.x +
		    t * t * p2.x;
		y = (1 - t) * (1 - t) * p0.y + 2 * (1 - t) * t * p1.y +
		    t * t * p2.y;
		z = (1 - t) * (1 - t) * p0.z + 2 * (1 - t) * t * p1.z +
		    t * t * p2.z;
		pts.push_back(vec3{x, y, z});
		t += 0.10f;
	    }
	}
    }
    vector<vec3> cam_dir;
    vector<vec3> pts;
    vector<vec3> cps;
};

enum class View {
    ZY = 0,
    ZX = 1,
};

pair<float, float> world_to_screen(const olc::PixelGameEngine * gm, const View vw, const glm::vec3 in) {
    float x{}, y{}, z{};
    float y_offset{}, x_offset{};
    float y_scale{}, x_scale{};
    float x_coord{}, y_coord{};
    switch (vw) {
	case View::ZY:
	    // Y is still Y but shifted
	    // Z is shown on the X-Axis
		x_offset = 10;
	    x_scale = gm->ScreenWidth() / (z_data_max + x_offset); 
	    x_coord = x_offset + in.z * x_scale;

	    y_offset = gm->ScreenHeight() / 2;
	    y_scale = -1.f * gm->ScreenHeight() / (2.f *  WORLD_Y_MAX); 
	    y_coord = y_offset + in.y * y_scale 

	    break;
	case View::ZX:
	    break;
    };
    return make_pair(x_coord, y_coord);
}

class Example : public olc::PixelGameEngine {
   public:
    View currView{};
    unique_ptr<camPath> path;
    Example() { sAppName = "Example"; }
    bool OnUserCreate() override {
	// Called once at the start, so create things here
	vector<vec3> cps = {vec3{0.0f, 10.0f, 0.f},  vec3{0.0f, 20.0f, 30.f},
			    vec3{0.f, 15.0f, 65.f},  vec3{0.f, 15.0f, 100.f},
			    vec3{0.f, 18.0f, 110.f}, vec3{0.f, 22.0f, 120.f},
			    vec3{0.f, 20.0f, 150.f}, vec3{0.f, 19.0f, 180.f},
			    vec3{0.f, 10.0f, 200.f}};
	path = make_unique<camPath>(camPath(cps));
	cout << "number of control points: " << path->cps.size() << endl;
	path->createPathFromCps();
	return true;
    }

    bool OnUserUpdate(float fElapsedTime) override {
	frameCnt++;
	this->Clear(olc::Pixel(olc::DARK_GREY));

	// draw axes
	// ZY
	// Z = 0 					X = ScreenHeight / 2
	// Z = WorldZMax 			X = ScreenWidth
	// Y = 0 					ScreenHeight / 2
	// Y = WorldYMax 			0
	//
	if (frameCnt % 15 == 0) {
	    const auto z_data_max_it =
		std::max_element(path->pts.begin(), path->pts.end(), comp_zmax);
	    const auto y_data_max_it =
		std::max_element(path->pts.begin(), path->pts.end(), comp_ymax);
	    const auto x_data_max_it =
		std::max_element(path->pts.begin(), path->pts.end(), comp_xmax);

	    z_data_max = (*z_data_max_it).z;
	    y_data_max = (*y_data_max_it).y;
	    x_data_max = (*x_data_max_it).x;
	}

	// draw axes
	float x0{}, y0{}, xmax{}, ymax{};
	switch (currView) {
	    case View::ZY:
		// y = y + ScreenHeight/2
		tie(x0,y0) = world_to_screen(this, View::ZY, glm::vec3{0.f,0.f,0.f});
		tie(xmax,ymax) = world_to_screen(this, View::ZY, glm::vec3{0.f,WORLD_Y_MAX,z_data_max});
		DrawLine(x0, y0, xmax, y0, olc::WHITE);
		DrawLine(xmax /2 , ymax, xmax/2, y0, olc::WHITE);
		break;
	    case View::ZX:
		break;
	};

	// draw path
	// draw control points
	switch (currView) {
	    case View::ZY:

		for (const auto& pt : path->pts) {
			auto [x,y] = world_to_screen(this, View::ZY, pt); 
		    Draw(x, y, olc::RED);
		    DrawCircle(x, y, 3, olc::RED);
		}

		for (const auto& pt : path->cps) {
		    // draw circles around control pts
			auto [x,y] = world_to_screen(this, View::ZY, pt); 
		    Draw(x, y, olc::GREEN);
		    DrawCircle(x, y, 3, olc::GREEN);
		}

		break;
	    case View::ZX:

		break;
	};
	// draw axis labels
	switch (currView) {
	    case View::ZY:
		break;
	    case View::ZX:
		break;
	};
	return true;
    }
};

int main() {
    setLogFile("log.txt");
    auto level = gxb::load_level("test");
    Example demo;
    // this matches a screen dimension of roughly 1000x700
    if (demo.Construct(500, 350, 2, 2, false, true, false))
	demo.Start();

    return 0;
}
